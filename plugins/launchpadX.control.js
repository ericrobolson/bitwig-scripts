//
// Copyright (c) 2022 Eric Robert Olson
// MIT License
//
// THIS IS AN AUTOGENERATED FILE AND SHOULD NOT BE MODIFIED BY HAND
// THIS IS AN AUTOGENERATED FILE AND SHOULD NOT BE MODIFIED BY HAND
// THIS IS AN AUTOGENERATED FILE AND SHOULD NOT BE MODIFIED BY HAND
// THIS IS AN AUTOGENERATED FILE AND SHOULD NOT BE MODIFIED BY HAND
//

//
// src/out/core/core_bitwig.js
//
var isMaxVelocity = function (velocity) {
    return velocity === 127;
};
var isMinVelocity = function (velocity) {
    return velocity === 0;
};
var createNoteIn = function (name, input) {
    return input.createNoteInput(name, 
    // midi messages
    "80????", // note off
    "90????", // note on
    "B0????", // cc commands
    "D0????", // aftertouch
    "E0????" // pitchbend
    );
};
//
// src/out/core/core_color.js
//
/**
 * Normalizes a color in a 0..1 range to a 0..127 range
 * @param c
 * @returns
 */
var normalizeColor = function (c) {
    return Math.round(c * 127);
};
//
// src/out/core/core_handlerApplication.js
//
var ApplicationHandler = /** @class */ (function () {
    function ApplicationHandler(host) {
        var _this = this;
        this.panelLayout = "ARRANGE" /* PanelLayout.arrange */;
        this.application = host.createApplication();
        var observer = this.application.panelLayout();
        observer.markInterested();
        observer.addValueObserver(function (layout) {
            _this.panelLayout = layout;
        });
    }
    ApplicationHandler.prototype.layout = function () {
        return this.panelLayout;
    };
    return ApplicationHandler;
}());
//
// src/out/core/core_handlerTrack.js
//
var Clip = /** @class */ (function () {
    function Clip() {
        this.hasContent = false;
        this.color = [0, 0, 0];
        this.index = -1;
        this.isStopQueued = false;
        this.isPlaying = false;
        this.isPlaybackQueued = false;
        this.isRecording = false;
        this.isRecordingQueued = false;
    }
    return Clip;
}());
var TrackHandler = /** @class */ (function () {
    function TrackHandler(host, id, name, numTracks, numSends, numScenes, showIndications) {
        var _this = this;
        this.colors = new Array(numTracks);
        this.clips = new Array(numTracks);
        this.trackQueuedForStop = new Array(numTracks);
        this.trackIsArmed = new Array(numTracks);
        this.bank = host.createMainTrackBank(numTracks, numSends, numScenes);
        this.cursor = host.createCursorTrack(id, name, 0, 0, true);
        var bankSize = this.bank.getSizeOfBank();
        var track, element;
        var _loop_1 = function () {
            var idx = bankIndex;
            track = this_1.bank.getItemAt(idx);
            this_1.trackQueuedForStop[idx] = false;
            track.isQueuedForStop().markInterested();
            track.isQueuedForStop().addValueObserver(function (isQueuedForStop) {
                _this.trackQueuedForStop[idx] = isQueuedForStop;
            });
            // Track elements
            {
                element = track.pan();
                element.markInterested();
                element.setIndication(true);
                element = track.volume();
                element.markInterested();
                element.setIndication(true);
                element = track.arm();
                element.markInterested();
                element.addValueObserver(function (isArmed) {
                    _this.trackIsArmed[idx] = isArmed;
                });
            }
            // Clip data
            {
                var clipLauncher = track.clipLauncherSlotBank();
                clips = new Array(numScenes);
                for (var j = 0; j < numScenes; j++) {
                    clips[j] = new Clip();
                }
                this_1.clips[idx] = clips;
                clipLauncher.addHasContentObserver(function (slotIndex, hasContent) {
                    _this.clips[idx][slotIndex].index = slotIndex;
                    _this.clips[idx][slotIndex].hasContent = hasContent;
                });
                clipLauncher.addIsStopQueuedObserver(function (slotIndex, isStopQueued) {
                    _this.clips[idx][slotIndex].isStopQueued = isStopQueued;
                });
                clipLauncher.addIsPlayingObserver(function (slotIndex, isPlaying) {
                    _this.clips[idx][slotIndex].isPlaying = isPlaying;
                });
                clipLauncher.addIsPlaybackQueuedObserver(function (slotIndex, isQueued) {
                    _this.clips[idx][slotIndex].isPlaybackQueued = isQueued;
                });
                clipLauncher.addIsRecordingObserver(function (slotIndex, isRecording) {
                    _this.clips[idx][slotIndex].isRecording = isRecording;
                });
                clipLauncher.addIsRecordingQueuedObserver(function (slotIndex, isQueued) {
                    _this.clips[idx][slotIndex].isRecordingQueued = isQueued;
                });
                clipLauncher.addColorObserver(function (slotIndex, r, g, b) {
                    _this.clips[idx][slotIndex].index = slotIndex;
                    _this.clips[idx][slotIndex].color = [
                        normalizeColor(r),
                        normalizeColor(g),
                        normalizeColor(b),
                    ];
                });
            }
            // Set colors for track
            {
                this_1.colors[idx] = [0, 0, 0];
                track.color().addValueObserver(function (r, g, b) {
                    _this.colors[idx] = [
                        normalizeColor(r),
                        normalizeColor(g),
                        normalizeColor(b),
                    ];
                });
            }
        };
        var this_1 = this, clips;
        for (var bankIndex = 0; bankIndex < bankSize; bankIndex++) {
            _loop_1();
        }
        this.bank.followCursorTrack(this.cursor);
        this.cursor.solo().markInterested();
        this.cursor.mute().markInterested();
        this.bank.sceneBank().setIndication(showIndications);
    }
    return TrackHandler;
}());
//
// src/out/core/core_handlerTransport.js
//
var TransportHandler = /** @class */ (function () {
    function TransportHandler(host) {
        this.transport = host.createTransport();
    }
    return TransportHandler;
}());
//
// src/out/core/core_math.js
//
var index1dTo2d = function (index, width) {
    return [index % width, index / width];
};
var index2dTo1d = function (x, y, width, height) {
    return (y % height) * width + (x % width);
};
//
// src/out/consts.js
//
var ButtonState;
(function (ButtonState) {
    ButtonState[ButtonState["ToggledOn"] = 0] = "ToggledOn";
    ButtonState[ButtonState["ToggledOff"] = 1] = "ToggledOff";
    ButtonState[ButtonState["On"] = 2] = "On";
    ButtonState[ButtonState["Off"] = 3] = "Off";
})(ButtonState || (ButtonState = {}));
var getHexFromColorPalette = function (c) {
    switch (c) {
        case 18 /* ColorPalette.Yellow */:
            return "74";
        case 15 /* ColorPalette.HotPink */:
            return "5F";
        case 16 /* ColorPalette.White */:
            return "77";
        case 17 /* ColorPalette.Dirt */:
            return "47";
        case 12 /* ColorPalette.Blue */:
            return "4F";
        case 13 /* ColorPalette.BlueLighter */:
            return "25";
        case 14 /* ColorPalette.BlueDarker */:
            return "27";
        case 9 /* ColorPalette.Green */:
            return "57";
        case 10 /* ColorPalette.GreenLighter */:
            return "19";
        case 11 /* ColorPalette.GreenDarker */:
            return "17";
        case 6 /* ColorPalette.Red */:
            return "05";
        case 8 /* ColorPalette.RedDarker */:
            return "07";
        case 7 /* ColorPalette.RedLighter */:
            return "04";
        case 3 /* ColorPalette.Orange */:
            return "54";
        case 5 /* ColorPalette.Purple */:
            return "37";
        case 4 /* ColorPalette.Off */:
        default:
            println("Got unmapped color ".concat(c));
            return "00";
    }
};
var NUM_TRACKS = 8;
var NUM_SENDS = 8;
var NUM_SCENES = 8;
var GRID_WIDTH = 8;
var GRID_HEIGHT = 8;
var DIRECTIONAL_BTN_COUNT = 4;
var NUM_NOTES = 128;
var BACKGROUND_LIGHT_STRENGTH = 0.1;
//
// src/out/controlButtons.js
//
/**
 * State representing a Launchpad's Control Buttons.
 */
var ControlButtons = /** @class */ (function () {
    function ControlButtons() {
        this.up = false;
        this.down = false;
        this.left = false;
        this.right = false;
        this.session = false;
        this.note = false;
        this.custom = false;
        this.record = false;
        this.volume = false;
        this.pan = false;
        this.sendA = false;
        this.sendB = false;
        this.stopClip = false;
        this.mute = false;
        this.solo = false;
        this.recordArm = false;
    }
    ControlButtons.isUp = function (x, y) {
        return x == 0 && y == GRID_HEIGHT;
    };
    ControlButtons.isDown = function (x, y) {
        return x == 1 && y == GRID_HEIGHT;
    };
    ControlButtons.isLeft = function (x, y) {
        return x == 2 && y == GRID_HEIGHT;
    };
    ControlButtons.isRight = function (x, y) {
        return x == 3 && y == GRID_HEIGHT;
    };
    ControlButtons.isSession = function (x, y) {
        return x == 4 && y == GRID_HEIGHT;
    };
    ControlButtons.isNote = function (x, y) {
        return x == 5 && y == GRID_HEIGHT;
    };
    ControlButtons.isCustom = function (x, y) {
        return x == 6 && y == GRID_HEIGHT;
    };
    ControlButtons.isCaptureMidi = function (x, y) {
        return x == 7 && y == GRID_HEIGHT;
    };
    ControlButtons.isVolume = function (x, y) {
        return x == GRID_WIDTH && y == 7;
    };
    ControlButtons.isPan = function (x, y) {
        return x == GRID_WIDTH && y == 6;
    };
    ControlButtons.isSendA = function (x, y) {
        return x == GRID_WIDTH && y == 5;
    };
    ControlButtons.isSendB = function (x, y) {
        return x == GRID_WIDTH && y == 4;
    };
    ControlButtons.isStopClip = function (x, y) {
        return x == GRID_WIDTH && y == 3;
    };
    ControlButtons.isMute = function (x, y) {
        return x == GRID_WIDTH && y == 2;
    };
    ControlButtons.isSolo = function (x, y) {
        return x == GRID_WIDTH && y == 1;
    };
    ControlButtons.isRecordArm = function (x, y) {
        return x == GRID_WIDTH && y == 0;
    };
    return ControlButtons;
}());
//
// src/out/gridButtons.js
//
var GridButtons = /** @class */ (function () {
    function GridButtons(width, height) {
        var _this = this;
        this.isOn = function (x, y) {
            return _this.items[index2dTo1d(x, y, _this.width, _this.height)];
        };
        this.set = function (x, y, isOn) {
            _this.items[index2dTo1d(x, y, _this.width, _this.height)] = isOn;
        };
        var capacity = width * height;
        this.width = width;
        this.height = height;
        this.items = new Array(capacity);
        for (var i = 0; i < capacity; i++) {
            this.items[i] = false;
        }
    }
    return GridButtons;
}());
//
// src/out/light.js
//
var light = function (x, y, type, color) {
    var index = x + 1 + (y + 1) * 10;
    return "".concat(type, " ").concat(uint8ToHex(index), " ").concat(color);
};
var rgbLight = function (x, y, r, g, b) {
    var color = "".concat(uint8ToHex(r), " ").concat(uint8ToHex(g), " ").concat(uint8ToHex(b));
    return light(x, y, "03" /* LightType.RGB */, color);
};
var flashingLight = function (x, y, colorA, colorB) {
    return light(x, y, "01" /* LightType.Flashing */, "".concat(getHexFromColorPalette(colorA), " ").concat(getHexFromColorPalette(colorB)));
};
var staticLight = function (x, y, color) {
    return light(x, y, "00" /* LightType.Static */, getHexFromColorPalette(color));
};
var pulsingLight = function (x, y, color) {
    return light(x, y, "02" /* LightType.Pulsing */, getHexFromColorPalette(color));
};
//
// src/out/renderer.js
//
var LaunchpadRenderer = /** @class */ (function () {
    function LaunchpadRenderer(width, height) {
        this.queuedLights = "";
        this.isDirty = false;
        this.currentCount = 0;
        this.MAX_LIGHTS = 81;
        var capacity = width * height;
        this.width = width;
        this.height = height;
        this.previousLights = new Array(capacity);
    }
    LaunchpadRenderer.prototype.pulsingLight = function (x, y, color) {
        this.setLight(x, y, pulsingLight(x, y, color));
    };
    LaunchpadRenderer.prototype.staticLight = function (x, y, color) {
        this.setLight(x, y, staticLight(x, y, color));
    };
    LaunchpadRenderer.prototype.flashingLight = function (x, y, a, b) {
        this.setLight(x, y, flashingLight(x, y, a, b));
    };
    LaunchpadRenderer.prototype.rgbLight = function (x, y, rUint8, gUint8, bUint8) {
        this.setLight(x, y, rgbLight(x, y, rUint8, gUint8, bUint8));
    };
    /**
     * Attempts to set the given light. If a given light already has that value, will skip sending that message.
     * @param x
     * @param y
     * @param sysexMsg
     */
    LaunchpadRenderer.prototype.setLight = function (x, y, sysexMsg) {
        if (this.currentCount < this.MAX_LIGHTS) {
            var index = index2dTo1d(x, y, this.width, this.height);
            if (this.previousLights[index] !== sysexMsg) {
                this.previousLights[index] = sysexMsg;
                this.queuedLights += sysexMsg;
                this.isDirty = true;
                this.currentCount += 1;
            }
        }
    };
    /**
     * Renders the given lights.
     */
    LaunchpadRenderer.prototype.present = function () {
        if (this.isDirty) {
            var sysex = "F0 00 20 29 02 0C 03 ".concat(this.queuedLights, " f7");
            println(this.queuedLights);
            sendSysex(sysex);
            this.clearQueue();
        }
    };
    /**
     * Resets the light queue.
     */
    LaunchpadRenderer.prototype.clearQueue = function () {
        this.isDirty = false;
        this.currentCount = 0;
        this.queuedLights = "";
    };
    return LaunchpadRenderer;
}());
//
// src/out/core/core_bitwig.js
//
var isMaxVelocity = function (velocity) {
    return velocity === 127;
};
var isMinVelocity = function (velocity) {
    return velocity === 0;
};
var createNoteIn = function (name, input) {
    return input.createNoteInput(name, 
    // midi messages
    "80????", // note off
    "90????", // note on
    "B0????", // cc commands
    "D0????", // aftertouch
    "E0????" // pitchbend
    );
};
//
// src/out/core/core_color.js
//
/**
 * Normalizes a color in a 0..1 range to a 0..127 range
 * @param c
 * @returns
 */
var normalizeColor = function (c) {
    return Math.round(c * 127);
};
//
// src/out/core/core_handlerApplication.js
//
var ApplicationHandler = /** @class */ (function () {
    function ApplicationHandler(host) {
        var _this = this;
        this.panelLayout = "ARRANGE" /* PanelLayout.arrange */;
        this.application = host.createApplication();
        var observer = this.application.panelLayout();
        observer.markInterested();
        observer.addValueObserver(function (layout) {
            _this.panelLayout = layout;
        });
    }
    ApplicationHandler.prototype.layout = function () {
        return this.panelLayout;
    };
    return ApplicationHandler;
}());
//
// src/out/core/core_handlerTrack.js
//
var Clip = /** @class */ (function () {
    function Clip() {
        this.hasContent = false;
        this.color = [0, 0, 0];
        this.index = -1;
        this.isStopQueued = false;
        this.isPlaying = false;
        this.isPlaybackQueued = false;
        this.isRecording = false;
        this.isRecordingQueued = false;
    }
    return Clip;
}());
var TrackHandler = /** @class */ (function () {
    function TrackHandler(host, id, name, numTracks, numSends, numScenes, showIndications) {
        var _this = this;
        this.colors = new Array(numTracks);
        this.clips = new Array(numTracks);
        this.trackQueuedForStop = new Array(numTracks);
        this.trackIsArmed = new Array(numTracks);
        this.bank = host.createMainTrackBank(numTracks, numSends, numScenes);
        this.cursor = host.createCursorTrack(id, name, 0, 0, true);
        var bankSize = this.bank.getSizeOfBank();
        var track, element;
        var _loop_1 = function () {
            var idx = bankIndex;
            track = this_1.bank.getItemAt(idx);
            this_1.trackQueuedForStop[idx] = false;
            track.isQueuedForStop().markInterested();
            track.isQueuedForStop().addValueObserver(function (isQueuedForStop) {
                _this.trackQueuedForStop[idx] = isQueuedForStop;
            });
            // Track elements
            {
                element = track.pan();
                element.markInterested();
                element.setIndication(true);
                element = track.volume();
                element.markInterested();
                element.setIndication(true);
                element = track.arm();
                element.markInterested();
                element.addValueObserver(function (isArmed) {
                    _this.trackIsArmed[idx] = isArmed;
                });
            }
            // Clip data
            {
                var clipLauncher = track.clipLauncherSlotBank();
                clips = new Array(numScenes);
                for (var j = 0; j < numScenes; j++) {
                    clips[j] = new Clip();
                }
                this_1.clips[idx] = clips;
                clipLauncher.addHasContentObserver(function (slotIndex, hasContent) {
                    _this.clips[idx][slotIndex].index = slotIndex;
                    _this.clips[idx][slotIndex].hasContent = hasContent;
                });
                clipLauncher.addIsStopQueuedObserver(function (slotIndex, isStopQueued) {
                    _this.clips[idx][slotIndex].isStopQueued = isStopQueued;
                });
                clipLauncher.addIsPlayingObserver(function (slotIndex, isPlaying) {
                    _this.clips[idx][slotIndex].isPlaying = isPlaying;
                });
                clipLauncher.addIsPlaybackQueuedObserver(function (slotIndex, isQueued) {
                    _this.clips[idx][slotIndex].isPlaybackQueued = isQueued;
                });
                clipLauncher.addIsRecordingObserver(function (slotIndex, isRecording) {
                    _this.clips[idx][slotIndex].isRecording = isRecording;
                });
                clipLauncher.addIsRecordingQueuedObserver(function (slotIndex, isQueued) {
                    _this.clips[idx][slotIndex].isRecordingQueued = isQueued;
                });
                clipLauncher.addColorObserver(function (slotIndex, r, g, b) {
                    _this.clips[idx][slotIndex].index = slotIndex;
                    _this.clips[idx][slotIndex].color = [
                        normalizeColor(r),
                        normalizeColor(g),
                        normalizeColor(b),
                    ];
                });
            }
            // Set colors for track
            {
                this_1.colors[idx] = [0, 0, 0];
                track.color().addValueObserver(function (r, g, b) {
                    _this.colors[idx] = [
                        normalizeColor(r),
                        normalizeColor(g),
                        normalizeColor(b),
                    ];
                });
            }
        };
        var this_1 = this, clips;
        for (var bankIndex = 0; bankIndex < bankSize; bankIndex++) {
            _loop_1();
        }
        this.bank.followCursorTrack(this.cursor);
        this.cursor.solo().markInterested();
        this.cursor.mute().markInterested();
        this.bank.sceneBank().setIndication(showIndications);
    }
    return TrackHandler;
}());
//
// src/out/core/core_handlerTransport.js
//
var TransportHandler = /** @class */ (function () {
    function TransportHandler(host) {
        this.transport = host.createTransport();
    }
    return TransportHandler;
}());
//
// src/out/core/core_math.js
//
var index1dTo2d = function (index, width) {
    return [index % width, index / width];
};
var index2dTo1d = function (x, y, width, height) {
    return (y % height) * width + (x % width);
};
//
// src/out/launchpad/context.js
//
/**
 * Default, system wide transitions.
 * @param lp
 * @param context
 * @returns
 */
var contextDefaultTransition = function (lp, context) {
    var controlButtons = lp.controlButtons();
    // Non navigation control buttons
    {
        if (controlButtons.session) {
            return ContextArrange;
        }
        else if (controlButtons.custom) {
            return ContextCustom;
        }
        else if (controlButtons.volume) {
            //  return ContextVolume;
        }
        else if (controlButtons.pan) {
            //  return ContextPanControl;
        }
        else if (controlButtons.sendA) {
            //   return ContextSendA;
        }
        else if (controlButtons.sendB) {
            //   return ContextSendB;
        }
        else if (controlButtons.stopClip) {
            return ContextStopClip;
        }
        else if (controlButtons.mute) {
            //  return ContextMute;
        }
        else if (controlButtons.solo) {
            // return ContextSolo;
        }
        else if (controlButtons.recordArm) {
            return ContextRecordArm;
        }
    }
    // Navigation
    {
        if (controlButtons.up) {
            trackBankHandler.bank.scrollBackwards();
        }
        else if (controlButtons.down) {
            trackBankHandler.bank.scrollForwards();
        }
        if (controlButtons.left) {
            trackBankHandler.bank.sceneBank().scrollBackwards();
        }
        else if (controlButtons.right) {
            trackBankHandler.bank.sceneBank().scrollForwards();
        }
    }
    return context;
};
var getTrackFromGrid = function (y) {
    return trackBankHandler.bank.getItemAt(7 - y);
};
var paintTrackViewCell = function (renderer, row, col) {
    // Y needs to be inverted.
    var y = 7 - col;
    var x = row;
    var clip = trackBankHandler.clips[col][row];
    var queuedForStop = trackBankHandler.trackQueuedForStop[col] || clip.isStopQueued;
    if (clip.isPlaybackQueued) {
        renderer.pulsingLight(x, y, 10 /* ColorPalette.GreenLighter */);
    }
    else if (queuedForStop) {
        renderer.pulsingLight(x, y, 7 /* ColorPalette.RedLighter */);
    }
    else if (clip.isRecordingQueued) {
        renderer.pulsingLight(x, y, 7 /* ColorPalette.RedLighter */);
    }
    else if (clip.isRecording) {
        renderer.flashingLight(x, y, 8 /* ColorPalette.RedDarker */, 6 /* ColorPalette.Red */);
    }
    else if (clip.isPlaying) {
        renderer.flashingLight(x, y, 11 /* ColorPalette.GreenDarker */, 10 /* ColorPalette.GreenLighter */);
    }
    else if (clip.hasContent) {
        var _a = clip.color, clipR = _a[0], clipG = _a[1], clipB = _a[2];
        renderer.rgbLight(x, y, clipR, clipG, clipB);
    }
    else {
        var _b = trackBankHandler.colors[col], trackR = _b[0], trackG = _b[1], trackB = _b[2];
        renderer.rgbLight(x, y, trackR * BACKGROUND_LIGHT_STRENGTH, trackG * BACKGROUND_LIGHT_STRENGTH, trackB * BACKGROUND_LIGHT_STRENGTH);
    }
};
var paintGridTrackView = function (renderer) {
    for (var row = 0; row < NUM_SCENES; row++) {
        for (var col = 0; col < NUM_SCENES; col++) {
            paintTrackViewCell(renderer, row, col);
        }
    }
};
var paintFlashingGrid = function (renderer, a, b) {
    for (var row = 0; row < NUM_SCENES; row++) {
        for (var col = 0; col < NUM_SCENES; col++) {
            // Y needs to be inverted.
            var y = 7 - col;
            var x = row;
            renderer.flashingLight(x, y, a, b);
        }
    }
};
var paintColoredContext = function (context, renderer) {
    if (context.renderInstructions.gridOverride !== null) {
        for (var row = 0; row < NUM_SCENES; row++) {
            for (var col = 0; col < NUM_SCENES; col++) {
                context.renderInstructions.gridOverride(renderer, row, col);
            }
        }
    }
    else if (context.renderInstructions.grid === 2 /* ColorPalette.DefaultTrackBehavior */) {
        paintGridTrackView(renderer);
    }
    else {
        println("Need to figure out how I want to do alternate grid painting behavior. Defaulting to flashing pink and green.");
        paintFlashingGrid(renderer, 13 /* ColorPalette.BlueLighter */, 10 /* ColorPalette.GreenLighter */);
    }
    // Navigation buttons are secondary
    for (var x = 0; x < DIRECTIONAL_BTN_COUNT; x++) {
        renderer.staticLight(x, GRID_HEIGHT, context.renderInstructions.navigationButtons);
    }
    // Paint other control buttons
    {
        var draw = function (x, y) {
            return context.isTargetButton(x, y)
                ? renderer.pulsingLight(x, y, context.renderInstructions.targetButton)
                : renderer.staticLight(x, y, context.renderInstructions.otherButtons);
        };
        var x = 0;
        var y = GRID_HEIGHT;
        for (x = DIRECTIONAL_BTN_COUNT; x < NUM_SCENES; x++) {
            draw(x, y);
        }
        x = GRID_WIDTH;
        for (y = 0; y < NUM_SCENES; y++) {
            draw(x, y);
        }
    }
    // Paint logo
    {
        renderer.pulsingLight(GRID_WIDTH, GRID_HEIGHT, 7 /* ColorPalette.RedLighter */);
    }
};
//
// src/out/launchpad/contextArrange.js
//
var ContextArrange = {
    title: function () {
        return "ContextArrange";
    },
    shouldReplaceHistory: function () {
        return true;
    },
    transition: function (lp, note, velocity, prevVelocity, state, x, y, isGridButton) {
        var controlButtons = lp.controlButtons();
        if (state == ButtonState.ToggledOn && isGridButton) {
            var track = getTrackFromGrid(y);
            var clipLauncher = track.clipLauncherSlotBank();
            if (controlButtons.record) {
                clipLauncher.record(x);
            }
            else if (controlButtons.custom) {
                // delete clip
                clipLauncher.getItemAt(x).deleteObject();
            }
            else {
                clipLauncher.select(x);
                clipLauncher.launch(x);
            }
            return this;
        }
        return null;
    },
    isTargetButton: ControlButtons.isSession,
    renderInstructions: {
        targetButton: 12 /* ColorPalette.Blue */,
        navigationButtons: 9 /* ColorPalette.Green */,
        otherButtons: 3 /* ColorPalette.Orange */,
        grid: 2 /* ColorPalette.DefaultTrackBehavior */,
        gridOverride: null,
    },
};
//
// src/out/launchpad/contextCustom.js
//
var ContextCustom = {
    title: function () {
        return "ContextCustom/Delete";
    },
    shouldReplaceHistory: function () {
        return false;
    },
    transition: function (lp, note, velocity, prevVelocity, state, x, y, isGridButton) {
        var shouldReturnToPrevious = this.isTargetButton(x, y) && state == ButtonState.ToggledOn;
        if (shouldReturnToPrevious) {
            return lp.lastContext();
        }
        if (state == ButtonState.ToggledOn && isGridButton) {
            var track = getTrackFromGrid(y);
            var clipLauncher = track.clipLauncherSlotBank();
            clipLauncher.getItemAt(x).deleteObject();
            return this;
        }
        return contextDefaultTransition(lp, this);
    },
    isTargetButton: ControlButtons.isCustom,
    renderInstructions: {
        targetButton: 6 /* ColorPalette.Red */,
        navigationButtons: 17 /* ColorPalette.Dirt */,
        otherButtons: 11 /* ColorPalette.GreenDarker */,
        grid: 2 /* ColorPalette.DefaultTrackBehavior */,
        gridOverride: null,
    },
};
//
// src/out/launchpad/contextRecordArm.js
//
var ContextRecordArm = {
    title: function () {
        return "ContextRecordArm";
    },
    shouldReplaceHistory: function () {
        return false;
    },
    transition: function (lp, note, velocity, prevVelocity, state, x, y, isGridButton) {
        var shouldReturnToPrevious = this.isTargetButton(x, y) &&
            !isGridButton &&
            state == ButtonState.ToggledOn;
        if (shouldReturnToPrevious) {
            return lp.lastContext();
        }
        if (state == ButtonState.ToggledOn && isGridButton) {
            getTrackFromGrid(y).arm().toggle();
            return this;
        }
        return contextDefaultTransition(lp, this);
    },
    isTargetButton: ControlButtons.isRecordArm,
    renderInstructions: {
        targetButton: 10 /* ColorPalette.GreenLighter */,
        navigationButtons: 13 /* ColorPalette.BlueLighter */,
        otherButtons: 15 /* ColorPalette.HotPink */,
        grid: 2 /* ColorPalette.DefaultTrackBehavior */,
        gridOverride: function (renderer, row, col) {
            // Y needs to be inverted.
            var y = 7 - col;
            var x = row;
            var shouldDrawRecordArmed = x > 5 || x < 2;
            if (trackBankHandler.trackIsArmed[col] && shouldDrawRecordArmed) {
                renderer.flashingLight(x, y, 8 /* ColorPalette.RedDarker */, 7 /* ColorPalette.RedLighter */);
            }
            else {
                paintTrackViewCell(renderer, row, col);
            }
        },
    },
};
//
// src/out/launchpad/contextStopClip.js
//
var ContextStopClip = {
    title: function () {
        return "ContextStopClip";
    },
    shouldReplaceHistory: function () {
        return false;
    },
    transition: function (lp, note, velocity, prevVelocity, state, x, y, isGridButton) {
        var shouldReturnToPrevious = this.isTargetButton(x, y) && state == ButtonState.ToggledOn;
        if (shouldReturnToPrevious) {
            return lp.lastContext();
        }
        if (state == ButtonState.ToggledOn && isGridButton) {
            getTrackFromGrid(y).stop();
            return this;
        }
        return contextDefaultTransition(lp, this);
    },
    isTargetButton: ControlButtons.isStopClip,
    renderInstructions: {
        targetButton: 9 /* ColorPalette.Green */,
        navigationButtons: 12 /* ColorPalette.Blue */,
        otherButtons: 6 /* ColorPalette.Red */,
        grid: 2 /* ColorPalette.DefaultTrackBehavior */,
        gridOverride: null,
    },
};
//
// src/out/launchpad/launchpadx.js
//
/**
 * A class representing a Launchpad object.
 */
var LaunchpadObject = /** @class */ (function () {
    function LaunchpadObject() {
        var _this = this;
        /**
         * Attempts to set a control button's state.
         * @param x
         * @param y
         * @param isOn
         */
        this.maybeSetControlButtons = function (x, y, isOn) {
            // Set top row
            if (y == GRID_WIDTH && x >= 0 && x < GRID_WIDTH) {
                switch (x) {
                    case 0:
                        _this.controlButtonState.up = isOn;
                        break;
                    case 1:
                        _this.controlButtonState.down = isOn;
                        break;
                    case 2:
                        _this.controlButtonState.left = isOn;
                        break;
                    case 3:
                        _this.controlButtonState.right = isOn;
                        break;
                    case 4:
                        _this.controlButtonState.session = isOn;
                        break;
                    case 5:
                        _this.controlButtonState.note = isOn;
                        break;
                    case 6:
                        _this.controlButtonState.custom = isOn;
                        break;
                    case 7:
                        _this.controlButtonState.record = isOn;
                        break;
                }
            }
            // Set side buttons
            else if (x == GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                switch (y) {
                    case 0:
                        _this.controlButtonState.recordArm = isOn;
                        break;
                    case 1:
                        _this.controlButtonState.solo = isOn;
                        break;
                    case 2:
                        _this.controlButtonState.mute = isOn;
                        break;
                    case 3:
                        _this.controlButtonState.stopClip = isOn;
                        break;
                    case 4:
                        _this.controlButtonState.sendB = isOn;
                        break;
                    case 5:
                        _this.controlButtonState.sendA = isOn;
                        break;
                    case 6:
                        _this.controlButtonState.pan = isOn;
                        break;
                    case 7:
                        _this.controlButtonState.volume = isOn;
                        break;
                }
            }
        };
        this.contextPrevious = null;
        this.context = ContextArrange;
        this.renderer = new LaunchpadRenderer(GRID_WIDTH, GRID_HEIGHT);
        this.gridButtons = new GridButtons(GRID_WIDTH, GRID_HEIGHT);
        this.prevVelocities = new Array(NUM_NOTES);
        this.noteVelocities = new Array(NUM_NOTES);
        for (var i = 0; i < NUM_NOTES; i++) {
            this.prevVelocities[i] = 0;
            this.noteVelocities[i] = 0;
        }
        var previousLightsSize = GRID_WIDTH * GRID_HEIGHT;
        this.previousLights = new Array(previousLightsSize);
        for (var i = 0; i < previousLightsSize; i++) {
            this.previousLights[i] = "";
        }
        this.controlButtonState = new ControlButtons();
        this.gridButtons = new GridButtons(GRID_WIDTH, GRID_HEIGHT);
    }
    /**
     * Returns the panel layout for the DAW.
     */
    LaunchpadObject.prototype.layout = function () {
        return applicationHandler.layout();
    };
    /**
     * Returns the control button state.
     * @returns the control button state.
     */
    LaunchpadObject.prototype.controlButtons = function () {
        return this.controlButtonState;
    };
    /**
     * Returns the last context page.
     * @returns
     */
    LaunchpadObject.prototype.lastContext = function () {
        return this.contextPrevious ? this.contextPrevious : ContextArrange;
    };
    /**
     * Callback for handling midi notes.
     * @param _status
     * @param note
     * @param velocity
     */
    LaunchpadObject.prototype.handleMidi = function (_status, note, velocity) {
        var x = (note % 10) - 1;
        var y = Math.floor(note / 10) - 1;
        var prevVelocity = this.noteVelocities[note];
        this.prevVelocities[note] = prevVelocity;
        this.noteVelocities[note] = velocity;
        var toggledOn = prevVelocity === 0 && velocity !== 0;
        var toggledOff = prevVelocity > 0 && velocity === 0;
        var isOn = velocity > 0;
        var isGridButton = x < GRID_WIDTH && y < GRID_HEIGHT;
        if (isGridButton) {
            this.gridButtons.set(x, y, isOn);
        }
        else {
            this.maybeSetControlButtons(x, y, isOn);
        }
        var buttonState = ButtonState.Off;
        if (toggledOn) {
            buttonState = ButtonState.ToggledOn;
        }
        else if (toggledOff) {
            buttonState = ButtonState.ToggledOff;
        }
        else if (isOn) {
            buttonState = ButtonState.On;
        }
        var newContext = this.context.transition(this, note, velocity, prevVelocity, buttonState, x, y, isGridButton);
        if (newContext === null) {
            newContext = contextDefaultTransition(this, this.context);
        }
        if (this.context.shouldReplaceHistory()) {
            this.contextPrevious = this.context;
        }
        this.context = newContext;
    };
    /**
     * Flushes the Launchpad, performing any rendering updates.
     */
    LaunchpadObject.prototype.flush = function () {
        paintColoredContext(this.context, this.renderer);
        this.renderer.present();
    };
    return LaunchpadObject;
}());
//
// src/out/launchpad/todo_contexts/contextMute.js
//
/*
const ContextMute: Context = {
  title(): string {
    return "ContextMute";
  },
  isTargetButton: (x: number, y: number): boolean =>
    ControlButtons.isMute(x, y),
  shouldReplaceHistory() {
    return false;
  },
  transition(
    lp: LaunchpadObject,
    note: number,
    velocity: number,
    prevVelocity: number,
    state: ButtonState,
    x: number,
    y: number,
    isGridButton: boolean
  ): Context {
    const triggerButton = lp.controlButtons().mute;
    const shouldReturnToPrevious =
      triggerButton && !isGridButton && state == ButtonState.ToggledOn;

    if (shouldReturnToPrevious) {
      return lp.lastContext();
    }

    return contextDefaultTransition(lp, this);
  },
  render(lp: LaunchpadObject, renderer: RenderQueue) {
    // Paint grid
    {
      for (var row = 0; row < NUM_SCENES + 1; row++) {
        for (var col = 0; col < NUM_SCENES + 1; col++) {
          renderer.staticLight(row, col, ColorPalette.Blue);
        }
      }
    }

    // Paint logo
    {
      renderer.pulsingLight(8, 8, ColorPalette.BlueDarker);
    }
  },
};
*/
//
// src/out/launchpad/todo_contexts/contextPanControl.js
//
/*
const ContextPanControl: Context = {
  title(): string {
    return "ContextPanControl";
  },
  shouldReplaceHistory() {
    return false;
  },
  transition(
    lp: LaunchpadObject,
    note: number,
    velocity: number,
    prevVelocity: number,
    state: ButtonState,
    x: number,
    y: number,
    isGridButton: boolean
  ): Context {
    const triggerButton = lp.controlButtons().pan;
    const shouldReturnToPrevious =
      triggerButton && !isGridButton && state == ButtonState.ToggledOn;

    if (shouldReturnToPrevious) {
      return lp.lastContext();
    }

    return contextDefaultTransition(lp, this);
  },
  render(lp: LaunchpadObject, renderer: RenderQueue) {
    // Paint grid
    {
      for (var row = 0; row < NUM_SCENES + 1; row++) {
        for (var col = 0; col < NUM_SCENES + 1; col++) {
          renderer.staticLight(row, col, ColorPalette.BlueLighter);
        }
      }
    }

    // Paint logo
    {
      renderer.pulsingLight(8, 8, ColorPalette.BlueDarker);
    }
  },
};
*/
//
// src/out/launchpad/todo_contexts/contextSendA.js
//
/*
const ContextSendA: Context = {
  title(): string {
    return "ContextSendA";
  },
  shouldReplaceHistory() {
    return false;
  },
  transition(
    lp: LaunchpadObject,
    note: number,
    velocity: number,
    prevVelocity: number,
    state: ButtonState,
    x: number,
    y: number,
    isGridButton: boolean
  ): Context {
    const triggerButton = lp.controlButtons().sendA;
    const shouldReturnToPrevious =
      triggerButton && !isGridButton && state == ButtonState.ToggledOn;

    if (shouldReturnToPrevious) {
      return lp.lastContext();
    }

    return contextDefaultTransition(lp, this);
  },
  render(lp: LaunchpadObject, renderer: RenderQueue) {
    // Paint grid
    {
      for (var row = 0; row < NUM_SCENES + 1; row++) {
        for (var col = 0; col < NUM_SCENES + 1; col++) {
          renderer.staticLight(row, col, ColorPalette.Dirt);
        }
      }
    }

    // Paint logo
    {
      renderer.pulsingLight(8, 8, ColorPalette.BlueDarker);
    }
  },
};
*/
//
// src/out/launchpad/todo_contexts/contextSendB.js
//
/*
const ContextSendB: Context = {
  title(): string {
    return "ContextSendB";
  },
  shouldReplaceHistory() {
    return false;
  },
  transition(
    lp: LaunchpadObject,
    note: number,
    velocity: number,
    prevVelocity: number,
    state: ButtonState,
    x: number,
    y: number,
    isGridButton: boolean
  ): Context {
    const triggerButton = lp.controlButtons().sendB;
    const shouldReturnToPrevious =
      triggerButton && !isGridButton && state == ButtonState.ToggledOn;

    if (shouldReturnToPrevious) {
      return lp.lastContext();
    }

    return contextDefaultTransition(lp, this);
  },
  render(lp: LaunchpadObject, renderer: RenderQueue) {
    // Paint grid
    {
      for (var row = 0; row < NUM_SCENES + 1; row++) {
        for (var col = 0; col < NUM_SCENES + 1; col++) {
          renderer.staticLight(row, col, ColorPalette.Green);
        }
      }
    }

    // Paint logo
    {
      renderer.pulsingLight(8, 8, ColorPalette.BlueDarker);
    }
  },
};
*/
//
// src/out/launchpad/todo_contexts/contextSolo.js
//
/*
const ContextSolo: Context = {
  title(): string {
    return "ContextSolo";
  },
  shouldReplaceHistory() {
    return false;
  },
  transition(
    lp: LaunchpadObject,
    note: number,
    velocity: number,
    prevVelocity: number,
    state: ButtonState,
    x: number,
    y: number,
    isGridButton: boolean
  ): Context {
    const triggerButton = lp.controlButtons().solo;
    const shouldReturnToPrevious =
      triggerButton && !isGridButton && state == ButtonState.ToggledOn;

    if (shouldReturnToPrevious) {
      return lp.lastContext();
    }

    return contextDefaultTransition(lp, this);
  },
  render(lp: LaunchpadObject, renderer: RenderQueue) {
    // Paint grid
    {
      for (var row = 0; row < NUM_SCENES + 1; row++) {
        for (var col = 0; col < NUM_SCENES + 1; col++) {
          renderer.staticLight(row, col, ColorPalette.GreenLighter);
        }
      }
    }

    // Paint logo
    {
      renderer.pulsingLight(8, 8, ColorPalette.BlueDarker);
    }
  },
};
*/
//
// src/out/launchpad/todo_contexts/contextVolume.js
//
/*
const ContextVolume: Context = {
  title(): string {
    return "ContextVolume";
  },
  shouldReplaceHistory() {
    return false;
  },
  transition(
    lp: LaunchpadObject,
    note: number,
    velocity: number,
    prevVelocity: number,
    state: ButtonState,
    x: number,
    y: number,
    isGridButton: boolean
  ): Context | null {
    const triggerButton = lp.controlButtons().volume;
    const shouldReturnToPrevious =
      triggerButton && !isGridButton && state == ButtonState.ToggledOn;

    if (shouldReturnToPrevious) {
      return lp.lastContext();
    }

    return contextDefaultTransition(lp, this);
  },
  render(lp: LaunchpadObject, renderer: RenderQueue) {
    // Paint grid
    {
      for (var row = 0; row < NUM_SCENES + 1; row++) {
        for (var col = 0; col < NUM_SCENES + 1; col++) {
          renderer.staticLight(row, col, ColorPalette.HotPink);
        }
      }
    }

    // Paint logo
    {
      renderer.pulsingLight(8, 8, ColorPalette.BlueDarker);
    }
  },
};
*/
//
// src/out/launchpadX.control.js
//
/////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// SCRIPT INIT //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
loadAPI(17);
host.setShouldFailOnDeprecatedUse(true);
host.defineController("Generic", "Launchpad X-Treme - Eric Olson", "0.2", "FC7C731D-C6D9-4627-875C-D0AA397BA73A");
host.defineMidiPorts(1, 1);
host.addDeviceNameBasedDiscoveryPair(["Launchpad X"], ["Launchpad X"]);
for (var i = 0; i < 10; i++) {
    host.addDeviceNameBasedDiscoveryPair(["MIDIIN".concat(i, " (LPX MIDI)")], ["MIDIOUT".concat(i, " (LPX MIDI)")]);
}
host.addDeviceNameBasedDiscoveryPair(["LPX MIDI"], ["LPX MIDI"]);
//TODO: need to add in more named discovery pairs.
var transportHandler;
var trackBankHandler;
var launchpad;
var applicationHandler;
var init = function () {
    sendSysex("F0 00 20 29 02 0C 00 7F F7" /* Sysex.programmerMode */);
    var inputPort = host.getMidiInPort(0);
    inputPort.setMidiCallback(onMidi);
    inputPort.setSysexCallback(onSysex);
    launchpad = new LaunchpadObject();
    applicationHandler = new ApplicationHandler(host);
    transportHandler = new TransportHandler(host);
    trackBankHandler = new TrackHandler(host, "LPX_TrackHandler", "LPX_TrackHandler_Cursor", NUM_TRACKS, NUM_SCENES, NUM_SENDS, true);
};
// Called when a short MIDI message is received on MIDI input port 0.
function onMidi(status, note, velocity) {
    launchpad.handleMidi(status, note, velocity);
}
// Called when a MIDI sysex message is received on MIDI input port 0.
function onSysex(data) {
    println("sysex: ".concat(data));
}
function flush() {
    launchpad.flush();
}
var exit = function () {
    sendSysex("F0 00 20 29 02 0C 00 00 F7" /* Sysex.sessionMode */);
};
/////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// SCRIPT INIT //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
